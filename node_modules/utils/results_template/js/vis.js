var objects_storage = {};
var oldRequestAnimationFrame = requestAnimationFrame;

var setup_animation_for_world = function(result_index) {

  $("body").append(
    "<div class='results' id='results" + result_index +
    "'></div>"
  );
  $( "#results" + result_index ).append(
    "<h3>" + result_index + ".</h3>"
  );
  var color_step = Math.round((99-55)/results.length);
  var shading = 55 + result_index*color_step;
  var color = "#" + shading + shading + shading;
  $( "#results" + result_index ).css({
    "background-color": color,
    "padding": "10px"
  });
  $( "#results" + result_index ).append(
    "<p id='label" + result_index + "'></p>"
  );
  $( "#results" + result_index ).append(
    "<p id='world" + result_index + "'></p>"
  );
  $( "#button" + result_index ).append(
    "<button>Animate</button>"
  );

  var label = results[result_index].label;
  // <div id="results"></div>
  $( "#label" + result_index ).append(label);
  var w = results[result_index].world;
  $( "#world" + result_index ).append(JSON.stringify(w));

  init();
  animate();

  // init();
  // animate();

  function init(){

    objects_storage["world" + result_index] = setup_physics(w, result_index);

    // Pixi.js zoom level
    objects_storage["zoom" + result_index] = 10;

    // Initialize the stage
    objects_storage["renderer" + result_index] =  PIXI.autoDetectRenderer(400, 200),
    objects_storage["stage" + result_index] = new PIXI.Stage(0xFFFFFF);

    // We use a container inside the stage for all our content
    // This enables us to zoom and translate the content
    objects_storage["container" + result_index] =     new PIXI.DisplayObjectContainer(),
    objects_storage["stage" + result_index].addChild(objects_storage["container" + result_index]);

    // Add the canvas to the DOM
    $("#results" + result_index).append(objects_storage["renderer" + result_index].view);

    // Add transform to the container
    objects_storage["container" + result_index].position.x =  objects_storage["renderer" + result_index].width/2; // center at origin
    objects_storage["container" + result_index].position.y =  objects_storage["renderer" + result_index].height/2;
    objects_storage["container" + result_index].scale.x =  objects_storage["zoom" + result_index];  // zoom in
    objects_storage["container" + result_index].scale.y = -objects_storage["zoom" + result_index]; // Note: we flip the y axis to make "up" the physics "up"

    // Draw the box.
    objects_storage["drawn_ball_A_" + result_index] = new PIXI.Graphics();
    objects_storage["drawn_ball_A_" + result_index].beginFill(0xff0000);
    objects_storage["drawn_ball_A_" + result_index].drawCircle(0, 0, 1); // x, y, radius
    // graphics.drawRect(-boxShape.width/2, -boxShape.height/2, boxShape.width, boxShape.height);

    // Add the box to our container
    objects_storage["container" + result_index].addChild(objects_storage["drawn_ball_A_" + result_index]);

    objects_storage["drawn_ball_B_" + result_index] = new PIXI.Graphics();
    objects_storage["drawn_ball_B_" + result_index].beginFill(0x0000ff);
    objects_storage["drawn_ball_B_" + result_index].drawCircle(0, 0, 1); // x, y, radius
    objects_storage["container" + result_index].addChild(objects_storage["drawn_ball_B_" + result_index]);

  }

  // Create a capturer that exports an animated GIF
  // Notices you have to specify the path to the gif.worker.js 
  objects_storage["gifcapturer" + result_index] = new CCapture( {
    format: 'gif',
    workersPath: '../node_modules/utils/node_modules/gif.js/dist/',
    framerate: 60
  } );
  objects_storage["webmcapturer" + result_index] = new CCapture( {
    format: 'webm',
    framerate: 60
  } );
  // When you have everything ready to start capturing,
  // and your animation loop is running, call:

  objects_storage["i" + result_index] = 0;
  var end_animation_frame = 90;
  objects_storage["first_animation" + result_index] = true;
  objects_storage["capture" + result_index] = false;
  var buffer_frame = 1;
  var post_animation_buffer = 30;

  function restart_physics() {
    objects_storage["i" + result_index] = 0;
    physics_setup = setup_physics(w, result_index);
    animate();
  }

  function first_animation() {
    var i = objects_storage["i" + result_index];
    // this is the first animation, so make Animate and Capture buttons
    // but don't capture this time.

    // At the end of the first animation
    if (i==end_animation_frame) {
      objects_storage["first_animation" + result_index] = false;

      // draw animation button
      $("#results" + result_index).append(
        "<p><button id='button" + result_index + "'>Animate</button></p>");
      // animation button restarts physics AND sets animation state
      $("#button" + result_index).click(function() {
        restart_physics();
      });

      // draw capture button
      $("#results" + result_index).append(
        "<p><button id='capture_button" + result_index + "'>Capture</button></p>");
      // capture button restarts physics AND sets capture state
      $("#capture_button" + result_index).click(function() {
        objects_storage["capture" + result_index] = true;
        restart_physics();
        // capture button will only run once.
        $("#capture_button" + result_index).unbind("click");
        $("#capture_button" + result_index).toggle();
      });
    }
  }

  function capturing_animation() {
    var i = objects_storage["i" + result_index];
    // capturing animation, don't make buttons, do capture

    if (i == buffer_frame) {
      // set up capturer after a buffer period
      objects_storage["gifcapturer" + result_index].start();
      objects_storage["webmcapturer" + result_index].start();
    }

    if (i < (end_animation_frame + post_animation_buffer)) {
      // capture during animation period
      objects_storage["gifcapturer" + result_index].capture( objects_storage["renderer" + result_index].view );
      objects_storage["webmcapturer" + result_index].capture( objects_storage["renderer" + result_index].view );
    }

    // At the end of the capture (only runs once)
    if (i == (end_animation_frame + post_animation_buffer)) {
      objects_storage["capture" + result_index] = false;

      objects_storage["gifcapturer" + result_index].stop();
      objects_storage["webmcapturer" + result_index].stop();

      // make download button for webm
      $("#results" + result_index).append(
        "<button id='webmdownload" + result_index + "'>Download WebM</button>"
      );
      $("#webmdownload" + result_index).click(function() {
        objects_storage["webmcapturer" + result_index].save();
      });

      // make download button for gifs
      $("#results" + result_index).append(
        "<button id='gifdownload" + result_index + "'>Download gif (requires server)</button>"
      );
      $("#gifdownload" + result_index).click(function() {
        objects_storage["gifcapturer" + result_index].save();
      });

    }
  }

  // Animation loop
  function animate(t){
    objects_storage["i" + result_index] = objects_storage["i" + result_index] || 0;
    objects_storage["i" + result_index]++;
    var i = objects_storage["i" + result_index];
    t = t || 0;
    // freeze this, because capture overwrites it
    oldRequestAnimationFrame(animate);

    if (i < end_animation_frame) {
      // Move physics bodies forward in time
      objects_storage["world" + result_index].step(1/60);

      // Transfer positions of the physics objects_storage to Pixi.js
      objects_storage["drawn_ball_A_" + result_index].position.x = objects_storage["ballABody" + result_index].position[0];
      objects_storage["drawn_ball_A_" + result_index].position.y = objects_storage["ballABody" + result_index].position[1];

      // Transfer positions of the physics objects_storage to Pixi.js
      objects_storage["drawn_ball_B_" + result_index].position.x = objects_storage["ballBBody" + result_index].position[0];
      objects_storage["drawn_ball_B_" + result_index].position.y = objects_storage["ballBBody" + result_index].position[1];

      // Render scene
      objects_storage["renderer" + result_index].render(objects_storage["stage" + result_index]);
    }

    if (objects_storage["first_animation" + result_index]) {
      first_animation();
    } else if (objects_storage["capture" + result_index]) {
      capturing_animation();
    }
  }
}

for (var result_index = 0; result_index < results.length; result_index++) {
  setup_animation_for_world(result_index);
}