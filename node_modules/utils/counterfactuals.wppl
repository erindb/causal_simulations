var setup_counterfactuals = function(prior_functions, meaning, //utterancePrior,
stickiness, rewrite_worlds_from_rvs_fn) {

	var nested = utils.get_flag("--nested");
	if (nested) {
	  display("using nested CF inference");
	} else {
	  display("using flat CF inference");
	}

	var lifted = utils.get_flag("--lifted");


  var counterfactualize = function(utterance, cf_type) {
    if (cf_type == "how") {
      return utterance + " differently";
    } else {
      return "not " + utterance;
    }
  };

	var rewrite_worlds_from_rvs_fn = rewrite_worlds_from_rvs_fn ? rewrite_worlds_from_rvs_fn : function(w) {return w;}

	// for each of these, we separately infer the marginal dist

	// counterfactual prior iterates through random variables from world prior and
	// flips stickiness and uses marginal dist to resample.

	// if there are any deterministic variables, we can condition
	// on the exogenous random variables' values

	/* Counterfactual wrapper:
	For a given RV, there's a function `fn` that generates the
	prior distribution for that RV.

	There's also an `actual` value that that RV takes in the "real" world.
	We then consider what else could have happened instead. (counterfactually)

	We do this by either keeping the actual value of the RV the same
	or resampling from the prior.*/
	var cf = function(fn, actual) {
	  if (flip(stickiness)) {
	    return actual;
	  } else {
	    return fn();
	  }
	}
	var prior_sampler = function() {
	  return mapObj(prior_functions, function(fn, key) {
	    return [key, fn()];
	  });
	}
	var cf_dist = cache(function(actual_world) {
		return Infer({method: "enumerate", maxExecutions: 100000, model: function() {
		  return mapObj(actual_world, function(actual_value, rv_key) {
		    // // look up the prior function for this random variable:
		    var fn = prior_functions[rv_key];
		    // counterfactually sample, given the actual value:
		    // var cf_value = flip() ? actual_value : fn(actual_value);//cf(fn, actual_value);
		    return [rv_key, cf(fn, actual_value)];
		  });
		}});
	});
	var cf_sampler = function(actual_world) {
	  return sample(cf_dist(actual_world));
	}

	var cf_type_sampler = function() {
		return uniformDraw(["how", "whether"]);
	}

  // var cached_meaning = cache(function(arg_string) {
  //   var args = JSON.parse(arg_string);
  //   return meaning(args);
  // });

  var utterancePrior = cache(function(base_utterance) {
  	var alternative_utterances = base_utterance.split("|||");
  	if (alternative_utterances.length == 1) {
	    return Infer(function() {return uniformDraw([base_utterance, "silence"]);});
	  } else {
	  	var probs = map(function(u) {
	  		return Math.exp(-u.split(" ").length/5);
	  	}, alternative_utterances);
	  	return Infer(function() {
	  		// return uniformDraw(alternative_utterances);
	  		return categorical(probs, alternative_utterances);
	  	})
	  }
  });

  var cached_meaning = cache(meaning);


	var literal_listener = nested ? (cache(function(utterance, cf_premise_type, cf_conclusion_type) {
	  return safe_infer({method: "enumerate", maxExecutions: 100000000}, function() {
	    var w = prior_sampler();
	    var actual_world = rewrite_worlds_from_rvs_fn(w);

	    var words = utterance.split(" ");

	    if (words.indexOf("because") >= 0) {
	    	// display("because");
		    var cf_premise_type = utils.isString(cf_premise_type) ? cf_premise_type : cf_type_sampler();
		    var cf_conclusion_type = utils.isString(cf_conclusion_type) ? cf_conclusion_type : cf_type_sampler();

	      var cause_index = words.indexOf("because");
	      var causing_event = words.slice(cause_index+1).join(" ");
	      var caused_event = words.slice(0, cause_index).join(" ");
	      var cf_causing = counterfactualize(causing_event, cf_premise_type);
	      var cf_caused = counterfactualize(caused_event, cf_conclusion_type);
	      // display(cf_causing);
	      // display(cf_caused);

		    var concrete_true = (
		    	(meaning(causing_event, actual_world, "NA", "start")) &&
		    	(meaning(caused_event, actual_world, "NA", "end"))
		    );

		    if (concrete_true) {
			  	var cf_dist = safe_infer({method: "enumerate", maxExecutions: 100000000}, function() {
			    	var cf_w = cf_sampler(w);
			    	var cf_world = rewrite_worlds_from_rvs_fn(cf_w);
			    	return {
			    		factor: (meaning(cf_causing, cf_world, actual_world, "start")) ? 0 : -Infinity,
			    		result: (meaning(cf_caused, cf_world, actual_world, "end"))
			    	}
			    });

			    // display(cf_dist);

		    	var cf_factor = cf_dist == "Impossible" ? -Infinity : cf_dist.score(true);

		    	return {factor: cf_factor, result: rewrite_worlds_from_rvs_fn(w)}
		    } else {
		    	return {factor: -Infinity, result: rewrite_worlds_from_rvs_fn(w)}
		    }
		  } else {
		  	// display("other");
		  	var f = cached_meaning(
			    	utterance,
			    	rewrite_worlds_from_rvs_fn(w),
			    	"NA",
			    	"NA",
			    	"NA",
			    	"NA"
			    ) ? 0 : -Infinity;
		  	return {factor: f, result: rewrite_worlds_from_rvs_fn(w)};

		  }
	  });
	})) : (cache(function(utterance, cf_premise_type, cf_conclusion_type) {
	  return safe_infer({method: "enumerate", maxExecutions: 1000000}, function() {
	    var cf_premise_type = utils.isString(cf_premise_type) ? cf_premise_type : cf_type_sampler();
	    var cf_conclusion_type = utils.isString(cf_conclusion_type) ? cf_conclusion_type : cf_type_sampler();
	    var w = prior_sampler();
	    var cf_w = cf_sampler(w);
	    var f = (cached_meaning(
	    	utterance,
	    	rewrite_worlds_from_rvs_fn(w),
	    	rewrite_worlds_from_rvs_fn(cf_w),
	    	"NA",
	    	cf_premise_type,
	    	cf_conclusion_type
	    )) ? 0 : -Infinity;
	    // var f = 0;
	    return {factor: f, result: rewrite_worlds_from_rvs_fn(w)};
	  });
	}));


	var inspect_l0 = function(utterance, cf_premise_type, cf_conclusion_type) {
	  return Infer({method: "enumerate", maxExecutions: 1000000, model: function() {
	    var cf_premise_type = utils.isString(cf_premise_type) ? cf_premise_type : cf_type_sampler();
	    var cf_conclusion_type = utils.isString(cf_conclusion_type) ? cf_conclusion_type : cf_type_sampler();
	    var w = prior_sampler();
	    var cf_w = cf_sampler(w);
	    var f = (cached_meaning(
	    	utterance,
	    	rewrite_worlds_from_rvs_fn(w),
	    	rewrite_worlds_from_rvs_fn(cf_w),
	    	"NA",
	    	cf_premise_type,
	    	cf_conclusion_type
	    )) ? 0 : -Infinity;
	    // var f = 0;
	    return {factor: f, result: {w: rewrite_worlds_from_rvs_fn(w), cp: cf_premise_type, cc: cf_conclusion_type}};
	  }});
	};

 //  var w = {
	//   a_speed: -15,
	//   b_speed: -15,
	//   a_angle: Math.PI/4,
	//   b_angle: -Math.PI/4,
	//   a_exists: true,
	//   b_exists: true,
	//   a_position: {x: 30, y: 10},
	//   b_position: {x: 30, y: -10},
	//   e_velocity: {x: 0, y: 0},
	//   e_position: {x: 7, y: 0},
	//   block_a: "DNE",
	//   block_b: "DNE"
	// };

	// var actual_world = rewrite_worlds_from_rvs_fn(w);

var actual_world = {
  "A":{"velocity":{"x":-21.2132,"y":-10.6066},"position":{"x":30,"y":10}},
  "B":{"velocity":{"x":-21.2132,"y":10.6066},"position":{"x":30,"y":-10}},
  "E":{"velocity":{"x":0,"y":0},"position":{"x":7,"y":0}},
  "block_A_prob": 0.8,
  "block_B_prob": 0.2,
  "block_A":"DNE",
  "block_B":"DNE"};

	var is_actual_world = function(w) {
	  return JSON.stringify(w) == JSON.stringify(actual_world);
	}

	var inspect_nested = function(utterance, cf_premise_type, cf_conclusion_type, set_actual) {
	  return Infer({method: "enumerate", maxExecutions: 100000000}, function() {
	    var w = prior_sampler();
	    var actual_world = rewrite_worlds_from_rvs_fn(w);

			if (set_actual) {
				condition(is_actual_world(actual_world));
			}

	    var words = utterance.split(" ");
	    // display(words);

	    if (words.indexOf("because") >= 0) {
	    	// display("because");
		    var cf_premise_type = utils.isString(cf_premise_type) ? cf_premise_type : cf_type_sampler();
		    var cf_conclusion_type = utils.isString(cf_conclusion_type) ? cf_conclusion_type : cf_type_sampler();

	      var cause_index = words.indexOf("because");
	      var causing_event = words.slice(cause_index+1).join(" ");
	      var caused_event = words.slice(0, cause_index).join(" ");
	      var cf_causing = counterfactualize(causing_event, cf_premise_type);
	      var cf_caused = counterfactualize(caused_event, cf_conclusion_type);
	      // display(cf_causing);
	      // display(cf_caused);

		    var concrete_true = (
		    	(meaning(causing_event, actual_world, "NA", "start")) &&
		    	(meaning(caused_event, actual_world, "NA", "end"))
		    );

		    if (concrete_true) {
			  	var cf_dist = safe_infer({method: "enumerate", maxExecutions: 100000000}, function() {
			    	var cf_w = cf_sampler(w);
			    	var cf_world = rewrite_worlds_from_rvs_fn(cf_w);
			    	return {
			    		factor: (meaning(cf_causing, cf_world, actual_world, "start")) ? 0 : -Infinity,
			    		result: (meaning(cf_caused, cf_world, actual_world, "end"))
			    	}
			    });

			    // display(cf_dist);

		    	var cf_factor = cf_dist == "Impossible" ? -Infinity : cf_dist.score(true);

		    	return {factor: cf_factor, result: {w: rewrite_worlds_from_rvs_fn(w), cp: cf_premise_type, cc: cf_conclusion_type}}
		    } else {
		    	return {factor: -Infinity, result: {w: rewrite_worlds_from_rvs_fn(w), cp: cf_premise_type, cc: cf_conclusion_type}}
		    }
		  } else {
		  	// display("other");
		  	var f = cached_meaning(
			    	utterance,
			    	rewrite_worlds_from_rvs_fn(w),
			    	"NA",
			    	"NA",
			    	"NA",
			    	"NA"
			    ) ? 0 : -Infinity;
		  	return {factor: f, result: {w: rewrite_worlds_from_rvs_fn(w), cp: "NA", cc: "NA"}};

		  }
	  });
	};

	var speaker = cache(function(w, base_utterance, cf_premise_type, cf_conclusion_type) {
	  return safe_infer({method: "enumerate"}, function() {
	    var utterance = sample(utterancePrior(base_utterance));
      // display(utterance);
	    var l0 = literal_listener(utterance, cf_premise_type, cf_conclusion_type);
	    var f = (l0=="Impossible") ? -Infinity : l0.score(w);
	    return {
	    	factor: f,
	    	result: utterance
		  };
	  });
	});

	var pragmatic_listener = cache(function(utterance, base_utterance, return_cf_types, cf_premise_type_input, cf_conclusion_type_input) {
	  return safe_infer({method: "enumerate", maxExecutions: 1000000}, function() {
	  	// if cf type is a string or if we're not doing a lifted variable up to S1 (we're inferring at the L0 level) then take the input value
	  	var cf_premise_type = (utils.isString(cf_premise_type_input) || !lifted) ? cf_premise_type_input : cf_type_sampler();
		  var cf_conclusion_type = (utils.isString(cf_conclusion_type_input) || !lifted) ? cf_conclusion_type_input : cf_type_sampler();

	    var w = rewrite_worlds_from_rvs_fn(prior_sampler());
	    var likelihood = speaker(w, base_utterance, cf_premise_type, cf_conclusion_type);
	    var f = likelihood.score(utterance);
	    var r = return_cf_types ? {"w": w, "cf_premise_type": cf_premise_type, "cf_conclusion_type": cf_conclusion_type} : w

	    return {factor: f, result: r};
	  });
	});

	var pragmatic_speaker = cache(function(w, base_utterance) {
	  return safe_infer({method: "enumerate"}, function() {
	    var utterance = sample(utterancePrior(base_utterance));
      // display(utterance);
	    var l1 = pragmatic_listener(utterance, base_utterance, false);
	    var f = (l1=="Impossible") ? -Infinity : l1.score(w);
	    return {
	    	factor: f,
	    	result: utterance
		  };
	  });
	});

	var endorsement = function(w, utterance, level, cf_premise_type, cf_conclusion_type) {
		if (level == "pragmatic") {
			return Math.exp(pragmatic_speaker(w, utterance).score(utterance));
		} else {
		  return Math.exp(speaker(w, utterance).score(utterance));
		}
	}

	return {
		"cf": cf,
		"prior_sampler": prior_sampler,
		"cf_sampler": cf_sampler,
		"literal_listener": literal_listener,
		"speaker": speaker,
		"endorsement": endorsement,
		"pragmatic_listener": pragmatic_listener,
		"pragmatic_speaker": pragmatic_speaker,
		"inspect_l0": inspect_l0,
		"inspect_nested": inspect_nested
	}
}
