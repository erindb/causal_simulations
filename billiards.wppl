/*

TODO:

- rewrite statePrior in terms of exogenous randomness
- rewrite counterfactual to sample a shadow world by
  samping close exogenous randomness
- write physics simulator run_physics
- animate worlds
- write L0 and view worlds it chooses
- hope that a bunch of these involve A hitting B.

*/

var STICKINESS = 0.5;


// utils
var foreach = function(lst, fn) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};
var displayObj = function(x) {
  display(JSON.stringify(x, undefined, 2));
};
var discretizedUniform = function(a, b, nbins) {
  var width = b-a;
  var width_per_step = width/(nbins-1);
  return randomInteger(nbins)*width_per_step + a;
};
var factor_meaning = function(meaning) {
  factor(Math.log(meaning));
};

// World prior

// Prior over positions.
// 4x4 grid of starting positions.
var all_positions = reduce(function(x, acc) {
  return acc.concat(map(function(y) {
    return {x: x, y: y};
  }, _.range(2)));
}, [], _.range(2));
// 2 objects cannot start in the same position.
var positionPrior = function(available_positions) {
  var i = randomInteger(available_positions.length);
  return {
    available_positions: available_positions.slice(0, i).concat(
          available_positions.slice(i+1, available_positions.length)),
    position: available_positions[i]
  }
}
var positionsPrior = function(objects) {
  return reduce(
    function(o, acc) {
      var position_sample = positionPrior(acc.remaining);
      return {
        remaining: position_sample.available_positions,
        sampled: _.extend(acc.sampled, _.fromPairs([
          [o, position_sample.position]
        ]))
      };
    },
    {sampled: {}, remaining: all_positions},
    objects).sampled;
};

var velocityPrior = function() {
  return {
    x: discretizedUniform(-1, 1, 3),
    y: discretizedUniform(-1, 1, 3)
  };
}

// Prior over velocities
var velocitiesPrior = function(objects) {
  return reduce(function(o, acc) {
    var x_velocity = velocityPrior();
    var y_velocity = velocityPrior();
    return _.extend(acc, _.fromPairs([[
      o,
      {x: x_velocity, y: y_velocity}
    ]]));
  }, {}, objects);
};

var shadowVelocityPrior = function(v) {
  return flip(STICKINESS) ? v : velocityPrior();
};

var shadowPositionsPrior = function(positions) {
  return reduce(function(p, acc) {

  }, {}, _.toPairs(positions));
};

// Sample positions and velocities for each object
var statePrior = function() {
  // var objects = uniformDraw([
  //   [], ["A"], ["B"], ["A", "B"]
  // ]);
  var objects = ["A", "B"];
  return {
    objects: objects,
    positions: positionsPrior(objects),
    velocities: velocitiesPrior(objects)
  }
};

var shadowStatePrior = function(w) {
  var shadow_positions = shadowPositionsPrior(w.positions);
  var shadow_velocities = map(shadowVelocityPrior(v), w.velocities);
  return {
    objects: w.objects,
    positions: shadow_positions,
    velocities: shadow_velocities
  }
};

var all_true = function(meanings) {
  return reduce(function(meaning, acc) {
    return acc * meaning;
  }, 1, meanings);
};

// TODO run physics
var run_physics = function(w) {
  return w;
};

// if premise had been the case,
// then conclusion would have been the case
var counterfactual = function(premise, conclusion, w) {
  // TODO: sample in a sticky way
  var shadow_w = statePrior();
  condition(JSON.stringify(w.objects) == JSON.stringify(shadow_w.objects))
  // TODO: condition counterfactual world on counterfactual premise
  // log of probability of premise being true.
  // i.e. condition on truth of premise.
  // premise is on *initial conditions*
  factor_meaning(meaning(premise, shadow_w, "initial", undefined, w));
  // return whether or not conclusion is true
  // conclusion is on *final conditions*
  return meaning(conclusion, shadow_w, "final", undefined, w);
};

var disambiguate = function(utterance, cf_version) {
  if (utterance == "A moved" || utterance == "B moved") {
    if (cf_version == "how") {
      return utterance + " differently";
    } else if (cf_version == "whether") {
      return utterance;
    } else {
      display("error 2130498");
    }
  } else {
    return utterance;
  }
};

var explanation = function(explanans, explanandum, w, cf_version) {
  var disambiguated_explanans = disambiguate(explanans, cf_version);
  var disambiguated_explanandum = disambiguate(explanandum, cf_version);
  return all_true([
    // explanans is true.
    meaning(explanans, w, "initial"),
    // explanandum is true.
    meaning(explanandum, w, "final"),
    // counterfactually, if not explanans, then not explanandum.
    counterfactual(
      "not " + disambiguated_explanans,
      "not " + disambiguated_explanandum,
      w
    )
  ]);
};

var moved = function(w, obj, timing) {
  var obj_exists = w["objects"].indexOf(obj) >= 0;
  if (obj_exists) {
    var moved_at_start = (w["velocities"][obj]["x"] != 0 |
                          w["velocities"][obj]["y"] != 0);
    if (timing == "initial") {
      return moved_at_start;
    } else {
      var w_final = run_physics(w);
      var moved_at_end = (w_final["velocities"][obj]["x"] != 0 |
                          w_final["velocities"][obj]["y"] != 0);
      if (timing == "final") {
        return moved_at_end;
      } else {
        // if no timing specified, then any movement counts
        return moved_at_start | moved_at_end;
      }
    }
  } else {
    // TODO presupposition?
    return 0;
  }
};

var moved_differently = function(w, obj, original, timing) {
  var relevant_world = timing=="initial" ? w : run_physics(w);
  var relevant_original_world = timing=="initial" ? original : run_physics(original);
  // velocity for obj is different between world and original world
  var obj_exists = w["objects"].indexOf(obj) >= 0;
  if (!obj_exists) {
    return 0;
  } else {
    var x_different = (relevant_world["velocities"][obj]["x"] !=
                       relevant_original_world["velocities"][obj]["x"]);
    var y_different = (relevant_world["velocities"][obj]["y"] !=
                       relevant_original_world["velocities"][obj]["y"]);
    return (x_different | y_different);
  }
};

var meaning = function(utterance, w, timing, cf_version, original) {
  if (utterance == "silence") {
    return 1;
  } else if (utterance == "A moved B") {
    // A moved B ==>
    // A (exists|moved).
    // B moved.
    // If A had not (existed/moved), then B would not have moved.
    return explanation("A moved", "B moved", w, cf_version);
//   } else if (utterance == "A" || utterance == "B") {
//     return meaning(disambiguate(utterance, cf_version), w, timing);
  } else if (utterance == "A moved") {
    // A moved entails that A existed
    // (TODO: should this be a presupposition?)
    return moved(w, "A", timing);
  } else if (utterance == "B moved") {
    // B moved entails that B existed
    // (TODO: should this be a presupposition?)
    return moved(w, "B", timing);
  } else if (utterance == "A moved differently") {
    return moved_differently(w, "A", original, timing);
  } else if (utterance == "B moved differently") {
    return moved_differently(w, "B", original, timing);
  } else if (utterance == "A existed") {
    return w["objects"].indexOf("A") >= 0;
  } else if (utterance == "B existed") {
    return w["objects"].indexOf("B") >= 0;
  } else if (utterance.slice(0, 3) == "not") {
    return 1 - meaning(
      utterance.slice(4, utterance.length),
      w,
      timing,
      cf_version,
      original
    );
  }
};

var utterance = "A moved B";
var objects = ["A", "B"];

var w = Infer({method: "rejection", samples: 1}, function() {
  var w = statePrior();
  // ambiguity about the meaning of a counterfactual
  var cf_version = uniformDraw(["how", "whether"]);
  var m = meaning(utterance, w, undefined, cf_version);
  factor_meaning(m);
  return _.extend(w, _.fromPairs([
    ["cf_version", cf_version],
    ["meaning", m]
  ]));
}).support()[0];

displayObj(w);