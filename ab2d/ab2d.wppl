// webppl ab2d.wppl --require ../node_modules/utils/ --results_dir ../results/ --modules_dir ../node_modules/

// parameter of the model -- how closely should counterfactual
// RVs match actual RVs?
var STICKINESS = 0.53;

/* Velocity prior:
Each ball, A and B, can take any velocity between -1 and 1 
(or some set of equally spaced values in that region) with
equal probability.*/
// uncomment for continuous version:
// var velocity_prior = uniform(-1, 1);
// discrete version:
// var velocity_prior = function() {return uniformDraw([-1, 0, 1.0])}
var vs = map(function(x) {return _.round(x, 1)}, _.range(-1, 1.1, 0.2));
display(vs);
var velocity_prior = function() {return uniformDraw(vs)}


/* Prior functions
So that it's easier to compute the counterfactual, write the prior
in terms of independent random variables, each with its own distribution.
*/
var prior_functions = {
  a_velocity: velocity_prior,
  b_velocity: velocity_prior,
  a_position: function() {return 0;},
  b_position: function() {return 1;}
}

// run a physics simulator to see what the positions and
// velocities of A and B will be at a later timepoint.
// this version isn't general, just applies to this situation
var run_physics = function(w) {
  



  
  if (w.a_velocity > w.b_velocity && w.a_velocity != 0) {
    // assume mass = 1, because why not
    var total_momentum = (
      0.5*w.a_velocity*w.a_velocity + 
      0.5*w.b_velocity*w.b_velocity
    );
    // after collision, give them equal velocities, because i'm lazy
    var new_velocity = Math.sqrt(total_momentum);
    return {
      a_velocity: -Math.abs(new_velocity),
      b_velocity: Math.abs(new_velocity)
    }
  } else {
    return w;
  }
}

var moved = function(w, ball) {
  var v = (ball=="A") ? w.a_velocity : w.b_velocity;
  return !(Math.abs(v - 0) < 0.0001);
}

var meaning = function(utterance, actual_world, cf_world, timing) {
  if (utterance == "silence") {
    return true;
  } else if (utterance == "A caused B") {
    return (
      // first A moved
      (meaning("A moved", actual_world, "NA", "start")) &&
      // then B moved
      (meaning("B moved", actual_world, "NA", "end")) &&
      // and if A hadn't moved, then B wouldn't have moved
      (meaning("not A moved", cf_world, "NA", "start")) &&
      (meaning("not B moved", cf_world, "NA", "end"))
    )
  } else if (utterance == "A moved" && timing == "start") {
    return moved(actual_world, "A");
  } else if (utterance == "B moved" && timing == "start") {
    return moved(actual_world, "B");
  } else if (utterance == "A moved" && timing == "end") {
    var actual_world_later = run_physics(actual_world);
    return moved(actual_world_later, "A");
  } else if (utterance == "B moved" && timing == "end") {
    var actual_world_later = run_physics(actual_world);
    return moved(actual_world_later, "B");
  } else if (utterance == "not A moved") {
    return !(meaning("A moved", actual_world, cf_world, timing));
  } else if (utterance == "not B moved") {
    return !(meaning("B moved", actual_world, cf_world, timing));
  }
}


var utterancePrior = function() {
  return uniformDraw(["A caused B", "silence"]);
}

var CF = setup_counterfactuals(prior_functions, meaning, utterancePrior);
var literal_listener = CF.literal_listener;
var endorsement = CF.endorsement;

// literal_listener("A caused B");
endorsement({a_velocity: 1, b_velocity: 0, a_position: 0, b_position: 1});



