// webppl ab1d.wppl --require ../node_modules/utils/ --results_dir ../results/ --modules_dir ../node_modules/

var ab1d = function() {
  display("using discrete world prior");

  // Based on "An Improved Probabilistic Account of Counterfactual Reasoning"
  // Lucas & Kemp (2015)
  // On average, this proportion of random choices will be the same in the
  // counterfactual world relative to the actual world.
  var stickiness = (
    utils.get_variable("--s") ?
    utils.float(utils.get_variable("--s")) :
    0.53
  );
  display("stickiness parameter for counterfactuals: " + stickiness);


  // WORLD PRIOR
  var objects = ["A", "B"];


  // One of two positions: A to the left of B or B to the left of A.
  var positions_prior = function() {
    return uniformDraw(["AB", "BA"]);
  }
  var place_object = function(positions, obj) {
    if (positions=="AB") {
      return (obj=="A" ? 0 : 1);
    } else if (positions=="BA") {
      return (obj=="B" ? 0 : 1);
    } else {
      display("invalid input for `positions`: " + positions);
    }
  }

  // Number of different velocities is given in input.
  var n_velocities = (
    utils.get_variable("--velocities") ?
    utils.float(utils.get_variable("--velocities")) :
    3
  );
  var possible_velocities = (
    (n_velocities == 7) ?
    [-1, -.5, -.1, 0, 0.1, 0.5, 1] :
    (n_velocities == 21) ?
    [
      -1, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1,
      0,
      0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1
    ] :
    (n_velocities == 11) ?
    [
      -1, -0.8, -0.6, -0.4, -0.2,
      0,
      0.2, 0.4, 0.6, 0.8, 1
    ] :
    (n_velocities == 5) ?
    [
      -1, -0.5,
      0,
      0.5, 1
    ] :
    [-1, 0, 1]
  );
  display("possible velocities: " + possible_velocities);
  var velocity_prior = function() {
    return uniformDraw(possible_velocities);
  }
  var velocities_prior = function() {
    return _.fromPairs(map(function(obj) {
      return [obj, velocity_prior()];
    }, objects));
  }

  // World prior samples positions and velocities
  // This just generates the initial conditions. Physics is considered
  // independently.
  var world_prior = function() {
    var velocities = velocities_prior();
    var positions = positions_prior();
    return object_map(function(obj) {
      return {
        velocity: velocities[obj],
        position: place_object(positions, obj)
      };
    }, objects);
  }

  /*
  For each random variable in the original world_prior, the counterfactual
  version of that random choice is a linear combination of two distributions.
  Either 
   * it chooses the actual world's value for that variable with probability 1,
   or
   * it runs the same random choice that it would have in the normal world_prior

  The counterfactual_world_prior is based on the original world_prior. For any
  world_prior, we could compute a corresponding counterfactual world_prior.
  For convenience in writing these priors, all random are independent of one
  another. That way we can simply choose to keep or resample each choice,
  independent of whether we keep or resample the other choices. If we had
  dependent random choices, we would have to think about all the downstream
  effects of each counterfactual change. This would make our counterfactual
  sampler much more complicated.

  Since we're using the world_prior to sample initial conditions and then
  running a deterministic physics simulation off of that, it's pretty easy to
  think of the random choices as indepdentent. It's not clear why one inital
  condition would depend on another. However, any world_prior, including ones
  with dependent random choices, could be rewritten to be in terms of only
  independent random choices.

  TODO: write a higher order function to create the counterfactual_world_prior
  given the world_prior (rather than just writing it out like I've done here.)
  */
  var counterfactual_world_prior = function(actual_world) {
    var keep_position = flip(stickiness);
    var positions = keep_position ? "NA" : positions_prior();
    return object_map(function(obj) {
      var keep_velocity = flip(stickiness);
      return {
        velocity: (keep_velocity ? actual_world[obj].velocity :
                                   velocity_prior()),
        position: (keep_position ? actual_world[obj].position :
                                   place_object(positions, obj))
      };
    }, objects);

  }

  /*
  Alternative that Ari was thinking of:
  Resample or keep top-level nodes. If resampled, resample all dependent
  choices, else go down one more level and flip whether to keep or resample.
  (Or something else like that.)
  */

  // MEANINGS

  var all_true = function(meanings) {
    // display(meanings);
    return reduce(function(meaning, acc) {
      return acc * meaning;
    }, 1, meanings);
  };

  // if premise had been the case,
  // then conclusion would have been the case
  var counterfactual = function(args) {
    // how often is the conclusion true when the premise is?

    var counterfactual_world = counterfactual_world_prior(args.actual_world);
    // i.e. condition on truth of premise.
    // premise is on *initial conditions*
    var premise = meaning({
      utterance: args.premise,
      target_world: counterfactual_world,
      timing: "initial",
      // input true world as the "counterfactual" now
      alternative_world: args.actual_world
    });
    // factor_meaning(premise);
    // return whether or not conclusion is true
    // conclusion is on *final conditions*
    var conclusion = meaning({
      utterance: args.conclusion,
      target_world: counterfactual_world,
      timing: "final",
      alternative_world: args.actual_world
    });
    return conclusion & premise;
  };


  // If it's a whether counterfactual, this is negation. If it's a how
  // counterfactual, we say it's different.
  var get_alternative = function(utterance, cf_version) {
    if (utterance == "A moved" || utterance == "B moved") {
      if (cf_version == "how") {
        return utterance + " differently";
      } else if (cf_version == "whether") {
        return "not " + utterance;
      } else {
        display("error 2130498");
      }
    } else {
      return utterance;
    }
  };


  /*
  Returns the semantics for cause for this premise, conclusion, and
  counterfactual type (HH, HW, WH, WW).

  "A moved B" means all these things are true:
   - ball A (exists|moved).
   - B moved.
   - Counterfactually, if A had not (existed/moved/moved exactly that
     way), then B would not have (moved/moved exactly that way).

  The stuff in parens is different possible interpretations of the
  causing event.

  args = {
        causing_event
        caused_event
        actual_world
        cf_type_premise
        cf_type_conclusion
  }
  */
  var x_caused_y = function(args) {
    var alternative_to_causing_event = get_alternative(
      args.causing_event,
      args.cf_type_premise
    );
    var alternative_to_caused_event = get_alternative(
      args.caused_event,
      args.cf_type_conclusion
    );
    return all_true([
      // causing_event ("A moved") is true of the actual world @ the beginning
      meaning({
        utterance: args.causing_event,
        target_world: args.actual_world,
        timing: "initial"
      }),
      // caused_event ("B moved") is true of the actual world @ the end
      meaning({
        utterance: args.caused_event,
        target_world: args.actual_world,
        timing: "final"
      }),
      // counterfactually, if not causing_event, then not caused_event.
      counterfactual({
        premise: alternative_to_causing_event,
        conclusion: alternative_to_caused_event,
        actual_world: args.actual_world
      })
    ]);
  };

  var moved = function(w, obj, timing) {
    var moved_at_start = w[obj].velocity != 0;
    if (timing == "initial") {
      return moved_at_start;
    } else {
      var w_final = utils.run_physics(w);
      var moved_at_end = w_final[obj].velocity != 0;
      if (timing == "final") {
        return moved_at_end;
      } else {
        // if no timing specified, then any movement counts
        return moved_at_start | moved_at_end;
      }
    }
  };

  var moved_differently = function(w, obj, counterfactual_world, timing) {
    var relevant_world = timing=="initial" ? counterfactual_world : utils.run_physics(counterfactual_world);
    var relevant_original_world = timing=="initial" ? w : utils.run_physics(w);
    // velocity for obj is different between world and original world
    var object_moved_differently = (
      relevant_world[obj].velocity !=
      relevant_original_world[obj].velocity
    );
    var object_moved_at_all = (
      (relevant_world[obj].velocity) != 0 &&
      (relevant_original_world[obj].velocity != 0)
    );
    return object_moved_at_all & object_moved_differently;

  };

  /*
  args = {
    utterance := which utterance are we computing the meaning for
    target_world := which world are we computing the meaning for

    // could have these kinds: WW, WH, HW, HH
    cf_type_premise := how to interpret the CF for the premise
    cf_type_conclusion := how to interpret the CF for the conclution

    timing := is the proposition evaluated at the start or end of the physics
              simulation
  }
  */
  var meaning = function(args) {
    if (args.utterance == "silence") {
      return 1;
    } else if (args.utterance == "A moved B") {
      // "A moved B" means all these things are true:
      //  - ball A (exists|moved).
      //  - B moved.
      //  - Counterfactually, if A had not (existed/moved/moved exactly that
      //    way), then B would not have (moved/moved exactly that way).
      // The stuff in parens is different possible interpretations of the
      // causing event.
      return x_caused_y({
        // TODO: implement the version of this where the causing event is "A
        // existed"
        causing_event: "A moved",
        caused_event: "B moved",
        actual_world: args.target_world,
        cf_type_premise: args.cf_type_premise,
        cf_type_conclusion: args.cf_type_conclusion
      });
    } else if (args.utterance == "A moved") {
      // A moved entails that A existed
      // (TODO: should this be a presupposition?)
      return moved(args.target_world, "A", args.timing);
    } else if (args.utterance == "B moved") {
      // B moved entails that B existed
      // (TODO: should this be a presupposition?)
      return moved(args.target_world, "B", args.timing);
    } else if (args.utterance == "A moved differently") {
      return moved_differently(args.target_world, "A", args.alternative_world, args.timing);
    } else if (args.utterance == "B moved differently") {
      return moved_differently(args.target_world, "B", args.alternative_world, args.timing);
    } else if (args.utterance.slice(0, 3) == "not") {
      return 1 - meaning({
        utterance: args.utterance.slice(4, args.utterance.length),
        target_world: args.target_world,
        timing: args.timing,
        alternative_world: args.alternative_world
      });
    } else {
      display("no meaning registered for utterance: " + utterance);
    }
  };

  var cached_meaning = cache(function(arg_string) {
    var args = JSON.parse(arg_string);
    return meaning(args);
  });


  var sample_cf_type = function() {
    return uniformDraw(["how", "whether"]);
  }

  var l0 = function(utterance, cf_type_premise, cf_type_conclusion) {

    // Returns a distribution over actual worlds.
    return safe_infer({method: "enumerate"}, function() {
    // How vs whether counterfactuals
    var cf_type_premise = utils.isString(cf_type_premise) ? cf_type_premise : sample_cf_type();
    var cf_type_conclusion = utils.isString(cf_type_conclusion) ? cf_type_conclusion : sample_cf_type();
      // Sample a world from world_prior.
      var w = world_prior();
      // Meaning `m` is a number between 0 and 1 representing how well the
      // utterance matches the world.
      // To compute the meaning, input the utterance, the actual world,
      // and the lexical parameters that say which kind of counterfactuals to use.
      var m = meaning({
        utterance: utterance,
        target_world: w,
        cf_type_premise: cf_type_premise,
        cf_type_conclusion: cf_type_conclusion
      });
      return {prob: m, result: w};
    });
  };

  var utteranePrior = function() {
    return uniformDraw(["A moved B", "silence"]);
  }

  var s1 = cache(function(w) {
    return safe_infer({method: "enumerate"}, function() {
      var utterance = utteranePrior();
      var interpretation = l0(utterance, question_under_discussion);
      var factor = (interpretation == "Impossible" ?
        -Infinity :
        interpretation.score(w)
      );
      return {
        factor: factor,
        result: {
          utterance: utterance
        }
      }
    });
  });

  var label = ("_unlifted_" + n_velocities + "velocities" +
      "_s" + stickiness);

  return {
    l0: l0,
    s1: s1,
    label: label
  }

};
